# webを支える技術

- [webを支える技術](#webを支える技術)
- [01, 02 webとはなにか、webの歴史](#01-02-webとはなにかwebの歴史)
- [03 REST webのアーキテクチャスタイル](#03-rest-webのアーキテクチャスタイル)
- [第2部　URI](#第2部uri)
- [04 URIの仕様](#04-uriの仕様)
- [05 URIの設計](#05-uriの設計)
- [第3部 HTTP](#第3部-http)
- [06 HTTPの基本](#06-httpの基本)

# 01, 02 webとはなにか、webの歴史

- webを支えるのはHTTP, URI, HTML
- ハイパーメディアシステム
  - メディア（テキスト、画像、音声、映像など）をハイパーリンクで結びつけた構成システム
  - webが実現しているリンクは単方向リンク
- 分散システム
  - 複数のコンピュータを組み合わせて処理を分散させること
- REST
  - HTTPが転送しているのはリソースの状態の表現、という主張から名付けられた
  - HTMLはマークアップ言語なので、データを記述するためのフォーマットとしては冗長→jsonが注目されるように

# 03 REST webのアーキテクチャスタイル

- RESTはネットワークシステムのアーキテクチャスタイル
  - 代表的なのはクラサバ、RESTもクラサバの派生系
- リソース
  - web上に存在する、名前を持ったありとあらゆる情報
  - リソースの名前：URI
    - URIによってweb上のリソースを識別することができる
- アドレス可能性：リソースを簡単に指し示すことができる性質
- リソース：URIは1:Nの関係にできる

# 第2部　URI
# 04 URIの仕様

- Uniform Resource Identifier : 統一リソース識別子
  - web上に存在するリソースを一意に識別するID
- URIの例
  - http://blog.example.jp/entries/1
  - URIスキーム://ホスト名/パス
    - ホスト名はDNSで名前解決ができるドメイン名 or IPアドレス（つまり、インターネット上で一意に定まる）
    - パスはホストの中でリソースを一意に識別する
  - http://yamada:pass@blog.exmaple.jp:8000/search?q=test&debug=true#n10
    - URIスキーム://ユーザ情報＠ホスト名：ポート番号/パス?クエリパラメタ#URIフラグメント
    - ユーザ情報：ユーザ名とパスワードは:で区切る
    - クエリパラメタ：クライアントから動的にURIを生成するとき（検索サービスに検索キーワードを渡す、など）に使う
    - URIフラグメント：URIが指し示すリソース内部の、さらに細かい部分を特定するときに利用する
      - リソースがHTML文書の場合、id属性がn10である要素を示すことになる
- 絶対URIと相対URLがある
  - 基本はターミナルの絶対パス・相対パスと同じ概念
- 相対パスはそのままではクライアントが解釈できないので、起点となるURLが必要→ベースURI
- ベースURIを明示的に指定する方法
  - HTMLの場合：`<head>`要素の中に`<base>`要素を指定する
  - XMLの場合：`xml:base`属性を使えばどの要素でもベースURIを指定できる
- URIで使える文字はASCII文字（アルファベット、数字、記号）。日本語を使いたい場合は％エンコーディングする
  - 現代的なwebサイトの多くは文字エンコーディングにUTF-8を採用しているので、クライアントが入力した文字列を使ってURIを生成する場合はUTF-8を採用しておけばとりあえずは大丈夫
- スキーム一覧
  - https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
- URIの実装で気をつけること
  - 相対URIの解決と％エンコーディング
  - クライアントで相対URIを解決するのは面倒な処理が必要なので、WebサービスやWeb APIの実装時には絶対URIを使う
  - URIにASCII文字以外を入れる場合はUTF-8で文字エンコーディングするようにする

# 05 URIの設計

- クールURI
  -  URIが変わらない（変わりにくい）ことを指す
     -  昔はURIが変更になってリンク切れになることが日常茶飯事だった
  -  開発者ではない普通の人にもわかりやすい
-  変わりにくいURIを設計するために
   -  プログラミング言語に依存した拡張子やパスを含めない
      -  CGIの時代にはよくあった、今はCGIの性能面で課題があること、プログラミング言語の選択肢
   -  メソッド名やセッションIDを含めない
-  URIはそのリソースを表現する名詞にする
   -  あるリソースを取得する（GET）のか、更新する（UPDATE）のかはURIに適用するHTTPメソッドで決定するので、URIにGETなどの、リソースにたいして何をするかの動詞を含めるべきではない
-  URIを変更したい時
   -  リダイレクトを使う
-  URI設計のテクニック
   -  拡張子が必ずしも悪いわけではない、実装に依存しない拡張子にはメリットもある
      -  コンテントネゴシエーション（同じリソースを複数言語で表現したい場合）
      -  `Accept-language`ヘッダでクライアントが望む言語を指定できる
   -  マトリクスURI
      -  複数パラメタの組み合わせで表現するリソースに使う
         -  地図検索とか
   -  クライアント側のURIを作る際の注意点：URIをクライアントにとって不透明にする
      -  URIをクライアント側で組み立てたり、拡張子からリソースの内容を推測しにくいようにする必要がある
         -  ハックを防ぐため
      -  https://www.w3.org/TR/2004/REC-webarch-20041215/#uri-opacity
  

# 第3部 HTTP
# 06 HTTPの基本
- HTTPはwebの基盤となるプロトコル
- HTTPはTCP/IPがベースになっている
  - ネットワークインターフェース層
    - 物理的なケーブル、ネットワークアダプタの部分
  - インターネット層
    - ネットワークでデータを実際にやり取りする部分
    - 指定したIPアドレスを送り先として、パケット単位でデータを送る
      - IPではデータを送るだけ。きちんと届いたかどうかまでは保証しない
  - トランスポート層
    - IPが保証しなかったデータの転送を保証する
    - 「コネクション」を使ってデータがたどり着いたかどうかを保証する
      - コネクション：通信端末同士に確立される論理的な通信路のこと
      - データを送る経路ってことかな？
  - アプリケーション層
    - メール、DNS、HTTPを実現する層
    - ソケット（ネットワークでのデータのやり取りを抽象化したAPI）を使ってプログラムを作るのが一般的
    - 大抵のプログラミング言語にはHTTPを実装したライブラリが標準でついており、開発においてこれを意識することは基本ない
      - JSだと`WebSocket`というオブジェクトがある
      - 参考になりそう？：https://zenn.dev/moyasi_niions/articles/04b10f36ba4d7b
- HTTPのバージョン
  - HTTP0.9
    - メソッドはGETのみ
    - ヘッダもなかった
  - HTTP1.0
    - HTTP最初の標準化
      - ブラウザ戦争が最激化していた頃に仕様策定が行われた
    - ヘッダの導入、GET以外のメソッドの追加などが行われた
  - HTTP1.1
    - チャンク転送、Acceptヘッダによるコンテントネゴシエーション、複雑なキャッシュコントロール、持続的接続などの機能追加が行われた
- リクエストとレスポンス
  - クライアントがすること
    - リクエストメッセージの構築
    - リクエストメッセージの送信
    - （レスポンスが来るまで待つ）
    - レスポンスメッセージの受信
    - レスポンスメッセージの解析
    - クライアントの目的を達成するために必要な処理
  - サーバがすること
    - （リクエストが来るのを待つ）
    - リクエストメッセージの受信
    - リクエストメッセージの解析
    - 適切なアプリケーションプログラムへの処理の委譲
      - 更なるリクエストを送る的な？
    - アプリケーションプログラムから結果の構築
    - レスポンスメッセージの構築
    - レスポンスメッセージの送信
- HTTPはステートレス
  - サーバがクライアントのそれまでのリクエストを覚えていないこと
    - セッション状態を記憶している、と言い換えることができる
    - 覚えている方は「ステートフル」
  - スケールアウトが簡単になる
    - クライアントはどのサーバにもリクエストを送ることができるので
  - エラーハンドリングが難しくなる
    - 同じリクエストを複数回送っても、「前もこのリクエスト来たけど大丈夫？」的な確認をサーバ側ではしてくれないので