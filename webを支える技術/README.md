# webを支える技術

- [webを支える技術](#webを支える技術)
- [01, 02 webとはなにか、webの歴史](#01-02-webとはなにかwebの歴史)
- [03 REST webのアーキテクチャスタイル](#03-rest-webのアーキテクチャスタイル)
- [第2部　URI](#第2部uri)
- [04 URIの仕様](#04-uriの仕様)
- [05 URIの設計](#05-uriの設計)
- [第3部 HTTP](#第3部-http)
- [06 HTTPの基本](#06-httpの基本)
- [07 HTTPメソッド](#07-httpメソッド)
- [08 ステータスコード](#08-ステータスコード)
- [09 HTTPヘッダ](#09-httpヘッダ)
- [10 HTML](#10-html)
- [11 microformats](#11-microformats)
- [12 Atom](#12-atom)
- [13 Atom Publishing Protocol(AtomPub)](#13-atom-publishing-protocolatompub)
- [14 JSON(JavaScript Object Notation)](#14-jsonjavascript-object-notation)
- [15~17](#1517)

# 01, 02 webとはなにか、webの歴史

- webを支えるのはHTTP, URI, HTML
- ハイパーメディアシステム
  - メディア（テキスト、画像、音声、映像など）をハイパーリンクで結びつけた構成システム
  - webが実現しているリンクは単方向リンク
- 分散システム
  - 複数のコンピュータを組み合わせて処理を分散させること
- REST
  - HTTPが転送しているのはリソースの状態の表現、という主張から名付けられた
  - HTMLはマークアップ言語なので、データを記述するためのフォーマットとしては冗長→jsonが注目されるように

# 03 REST webのアーキテクチャスタイル

- RESTはネットワークシステムのアーキテクチャスタイル
  - 代表的なのはクラサバ、RESTもクラサバの派生系
- リソース
  - web上に存在する、名前を持ったありとあらゆる情報
  - リソースの名前：URI
    - URIによってweb上のリソースを識別することができる
- アドレス可能性：リソースを簡単に指し示すことができる性質
- リソース：URIは1:Nの関係にできる

# 第2部　URI
# 04 URIの仕様

- Uniform Resource Identifier : 統一リソース識別子
  - web上に存在するリソースを一意に識別するID
- URIの例
  - http://blog.example.jp/entries/1
  - URIスキーム://ホスト名/パス
    - ホスト名はDNSで名前解決ができるドメイン名 or IPアドレス（つまり、インターネット上で一意に定まる）
    - パスはホストの中でリソースを一意に識別する
  - http://yamada:pass@blog.exmaple.jp:8000/search?q=test&debug=true#n10
    - URIスキーム://ユーザ情報＠ホスト名：ポート番号/パス?クエリパラメタ#URIフラグメント
    - ユーザ情報：ユーザ名とパスワードは:で区切る
    - クエリパラメタ：クライアントから動的にURIを生成するとき（検索サービスに検索キーワードを渡す、など）に使う
    - URIフラグメント：URIが指し示すリソース内部の、さらに細かい部分を特定するときに利用する
      - リソースがHTML文書の場合、id属性がn10である要素を示すことになる
- 絶対URIと相対URLがある
  - 基本はターミナルの絶対パス・相対パスと同じ概念
- 相対パスはそのままではクライアントが解釈できないので、起点となるURLが必要→ベースURI
- ベースURIを明示的に指定する方法
  - HTMLの場合：`<head>`要素の中に`<base>`要素を指定する
  - XMLの場合：`xml:base`属性を使えばどの要素でもベースURIを指定できる
- URIで使える文字はASCII文字（アルファベット、数字、記号）。日本語を使いたい場合は％エンコーディングする
  - 現代的なwebサイトの多くは文字エンコーディングにUTF-8を採用しているので、クライアントが入力した文字列を使ってURIを生成する場合はUTF-8を採用しておけばとりあえずは大丈夫
- スキーム一覧
  - https://www.iana.org/assignments/uri-schemes/uri-schemes.xhtml
- URIの実装で気をつけること
  - 相対URIの解決と％エンコーディング
  - クライアントで相対URIを解決するのは面倒な処理が必要なので、WebサービスやWeb APIの実装時には絶対URIを使う
  - URIにASCII文字以外を入れる場合はUTF-8で文字エンコーディングするようにする

# 05 URIの設計

- クールURI
  -  URIが変わらない（変わりにくい）ことを指す
     -  昔はURIが変更になってリンク切れになることが日常茶飯事だった
  -  開発者ではない普通の人にもわかりやすい
-  変わりにくいURIを設計するために
   -  プログラミング言語に依存した拡張子やパスを含めない
      -  CGIの時代にはよくあった、今はCGIの性能面で課題があること、プログラミング言語の選択肢
   -  メソッド名やセッションIDを含めない
-  URIはそのリソースを表現する名詞にする
   -  あるリソースを取得する（GET）のか、更新する（UPDATE）のかはURIに適用するHTTPメソッドで決定するので、URIにGETなどの、リソースにたいして何をするかの動詞を含めるべきではない
-  URIを変更したい時
   -  リダイレクトを使う
-  URI設計のテクニック
   -  拡張子が必ずしも悪いわけではない、実装に依存しない拡張子にはメリットもある
      -  コンテントネゴシエーション（同じリソースを複数言語で表現したい場合）
      -  `Accept-language`ヘッダでクライアントが望む言語を指定できる
   -  マトリクスURI
      -  複数パラメタの組み合わせで表現するリソースに使う
         -  地図検索とか
   -  クライアント側のURIを作る際の注意点：URIをクライアントにとって不透明にする
      -  URIをクライアント側で組み立てたり、拡張子からリソースの内容を推測しにくいようにする必要がある
         -  ハックを防ぐため
      -  https://www.w3.org/TR/2004/REC-webarch-20041215/#uri-opacity
  

# 第3部 HTTP
# 06 HTTPの基本
- HTTPはwebの基盤となるプロトコル
- HTTPはTCP/IPがベースになっている
  - ネットワークインターフェース層
    - 物理的なケーブル、ネットワークアダプタの部分
  - インターネット層
    - ネットワークでデータを実際にやり取りする部分
    - 指定したIPアドレスを送り先として、パケット単位でデータを送る
      - IPではデータを送るだけ。きちんと届いたかどうかまでは保証しない
  - トランスポート層
    - IPが保証しなかったデータの転送を保証する
    - 「コネクション」を使ってデータがたどり着いたかどうかを保証する
      - コネクション：通信端末同士に確立される論理的な通信路のこと
      - データを送る経路ってことかな？
  - アプリケーション層
    - メール、DNS、HTTPを実現する層
    - ソケット（ネットワークでのデータのやり取りを抽象化したAPI）を使ってプログラムを作るのが一般的
    - 大抵のプログラミング言語にはHTTPを実装したライブラリが標準でついており、開発においてこれを意識することは基本ない
      - JSだと`WebSocket`というオブジェクトがある
      - 参考になりそう？：https://zenn.dev/moyasi_niions/articles/04b10f36ba4d7b
- HTTPのバージョン
  - HTTP0.9
    - メソッドはGETのみ
    - ヘッダもなかった
  - HTTP1.0
    - HTTP最初の標準化
      - ブラウザ戦争が最激化していた頃に仕様策定が行われた
    - ヘッダの導入、GET以外のメソッドの追加などが行われた
  - HTTP1.1
    - チャンク転送、Acceptヘッダによるコンテントネゴシエーション、複雑なキャッシュコントロール、持続的接続などの機能追加が行われた
- リクエストとレスポンス
  - クライアントがすること
    - リクエストメッセージの構築
    - リクエストメッセージの送信
    - （レスポンスが来るまで待つ）
    - レスポンスメッセージの受信
    - レスポンスメッセージの解析
    - クライアントの目的を達成するために必要な処理
  - サーバがすること
    - （リクエストが来るのを待つ）
    - リクエストメッセージの受信
    - リクエストメッセージの解析
    - 適切なアプリケーションプログラムへの処理の委譲
      - 更なるリクエストを送る的な？
    - アプリケーションプログラムから結果の構築
    - レスポンスメッセージの構築
    - レスポンスメッセージの送信
- HTTPはステートレス
  - サーバがクライアントのそれまでのリクエストを覚えていないこと
    - セッション状態を記憶している、と言い換えることができる
    - 覚えている方は「ステートフル」
  - スケールアウトが簡単になる
    - クライアントはどのサーバにもリクエストを送ることができるので
  - エラーハンドリングが難しくなる
    - 同じリクエストを複数回送っても、「前もこのリクエスト来たけど大丈夫？」的な確認をサーバ側ではしてくれないので

 # 07 HTTPメソッド
- HTTPメソッドは8つしかない
  - 実際使うのは5 or 6
- CRUDに対応するメソッド
  - GET
    - URIの情報を取得する
  - POST
    - 子リソースの作成
      - 成功したら201が返ってくる
      - 指定したリソースのパスに新しくパスができるイメージ
        - ブログの新規投稿とか
    - リソースへのデータ追加
      - リソース追加ではないので、成功レスポンスは200が返ってくる
      - リソースへのPOSTが作成（201）なのか、追加（200）なのかは実装に依存する、URIを見ただけではわからない
    - ほかのメソッドでは対応できない処理
      - 例：キーワードを入れてGETをしたいが、キーワードに文字数制限がある場合、キーワードをリクエストボディにしてPOSTする
  - PUT
    - リソースの更新
      - URIを指定して、更新したい値をリクエストボディに入れる
    - リソースの作成
      - touch コマンドみたいなイメージ
    - POSTとPUTの使い分け
      - POSTはリソースのURIを決めるのはサーバ、PUTはクライアント
        - 新規投稿した時、その投稿のURIが自動生成ならPUT,こちらで決めれる場合はPUT
          - ただし、PUTの時はリソースの上書きになるかどうかをクライアントで判定する必要があるので、シンプルな設計としてはPOSTを使うのが望ましい
  - DELETE
    - 成功した時のレスポンスボディは持たない（それはそう）
  - そのほか
    - HEAD
      - リソースのヘッダ取得
      - レスポンスにボディは含まれない
    - OPTIONS
      - リソースがサポートしているメソッドの取得
      - そのリソースが許可しているメソッドを一覧でレスポンスとして返してくれる
- POSTでPUT/DELETEを代用できる
  - 圧倒的に使われるのはGETとPOST
    - GETとPOSTしか使えないフォームもあったりする
  - _methodパラメタに`PUT`を代入する
  - X-HTTP-Method-Overrideヘッダに`PUT`を指定する
- 条件付きリクエスト
  - HTTPメソッドとヘッダを組み合わせて、リソースの更新日時に応じてリソースを更新するかどうかを選択できたりする
    - `If-Modified-Since`ヘッダというものがある
- 冪等性と安全性
  - PUTは冪等：失敗しても、同じリクエストを再度送って更新できる
    - 2回送っても、結果は1回目で成功した時と同じになる
  - DELETEも冪等：リソースを削除した後、同じリクエストを送ると404になる。削除後は何回リクエストしても404なので冪等
  - GETとHEADは冪等かつ安全
  - POSTは冪等でも安全でもない
    - 2回送ると2回送られてしまう
- 誤用するとPUTやDELETEも冪等ではなくなってしまう
  - PUT：リソースの差分をリクエストするとき
    - 100円のリソースに+50円をPUT→もう1回+50円をPUT
    - 結果：100円→150円→200円となり、冪等ではなくなる
      - 150円をPUTするべき
  - DELETE：削除するリソースがエイリアスではなく、意味的に値を持つ場合（変数として扱われている、という理解でいいのかな？）
    - `/latest`というパスへのDELETEで、latestが実際のバージョンとしての意味を持つ場合
    - 1回目のDELETE→今のバージョンが削除され、1つ戻る
    - もう1回DELETE→さらにもう1つバージョンが戻る
    - →冪等ではない

# 08 ステータスコード

- ステータスコードをどのように選択するかはWeb APIの設計において重要
  - 仕様で決まっているコードの意味を正しく理解する必要がある
- 1xx
  - 処理が継続している
- 2xx
  - リクエスト成功
- 3xx
  - リダイレクト
  - クライアントがこのステータスコードを受け取ると、レスポンスメッセージのLocationヘッダを見て新しいリソースを接続する
- 4xx
  - クライアントエラー
  - クライアントのリクエストに何かしらのエラーがあ理、これを解消しないとリクエストは通らない
  - 他に適切なクライアントエラーを示すステータスコードがない場合、400が返ってくる
    - よくわからないエラーはこれに集約される、ということか
- 5xx
  - サーバエラー
  - サーバ側のエラーを解消する必要がある
  - 未知の5xxエラーが来た時、500が返ってくる（400と同様）
- エラー処理はクライアントが解釈できる形式でエラーメッセージを返さないとだめ
  - 人間はHTMLを解釈できるが、プログラムは必ずしも解釈できないため
  - クライアントがAcceptヘッダを送信している場合、それを活用して動的なエラー表現が可能になる
- ステータスコードの設計
  - 誤用すると、404なのに検索エンジンのクローラにインデックスされるなど、不都合が生じる
  - Webサーバやフレームワークに応じて実装方法は変わってくる

# 09 HTTPヘッダ

- ヘッダはメッセージのボディに対する付加的な情報（メタデータ）
- 日時
  - Date
    - 全てGMTで記述することになっている（サマータイムを考慮しなくて済む）
- MIMEメディアタイプ
  - メッセージでやり取りするリソースの表現の種類を指定する
  - Content-Type
    - タイプ（独自に定義できない）とサブタイプ（比較的カスタマイズできる）を組み合わせられる
  - charset
    - 文字エンコーディングを指定する
- 言語タグ
  - Content-Language
- コンテントネゴシエーション
  - Accept
    - 処理できるメディアタイプを（クライアントがサーバに）伝える
    - クライアントがAcceptヘッダに指定したメディアタイプにサーバが対応していない場合、406 Not Accetableが返ってくる
  - Accept-Charset
    - 処理できる文字エンコーディングを（クライアントがサーバに）伝える
  - Accept-language
    - 処理できる言語を（クライアントがサーバに）伝える
- Content-Length
  - ボディの長さを指定する
  - チャンク転送
    - あらかじめデータサイズがわかっているリソース（静的なファイル）を返す場合はContent-Lengthを指定すれば良いが、データサイズが動的な場合はファイルサイズが決まるまでレスポンスを返せず、応答性能が良くない
    - そういうときに使える（Transfer-Encodingに`chunked`を指定する）
- 認証
  - `WWW-Authenticate`ヘッダを使って、サーバはクライアントにリソースのアクセスに必要な認証情報を伝えることができる
  - Basic認証
    - Base64エンコードした文字列を`Authorization`ヘッダに`:`の後に続ける
    - 簡単に破れる
  - Digest認証
    - Basic認証よりセキュア
    - チャレンジ
    - ダイジェストの生成と送信
  - WSSE認証
    - HTTP1.1では標準外の認証方式
  - OpenIDとOAuth
    -  SSOを実現するにはこれが不可欠（上述の認証だとSSOの要件を満たせない）
    -  Identity Provider(IdP): そのWebサービスのアカウントを他のWebサービスにも提供する側のこと
      -  Googleとか、Twitterとか
    -  IdPのアカウントを利用して独自のWebサービスを提供する側のことをService Provoder(SP)と呼ぶ
    -  OAuth：Webサービス間での認可の委譲
      -  ユーザが同意すれば、1つのアカウントで別のサービスに認証できるようにする
      -  〇〇が××の情報にアクセスすることを許可しますか？のやつ
-  キャッシュ
   -  サーバから取得したリソースをローカルストレージに蓄積し、再利用する手法
      -  キャッシュが有効な間、クライアントはそのリソースを再利用し続ける
   -  キャッシュ用ヘッダ
      -  Pragma
         -  `no-cache`以外の値は指定できない
      -  Expires
         -  キャッシュの有効期限を示す
      -  Cache-Contro;
         -  詳細なキャッシュ方法を指定する、HTTP1.1で追加された
            -  PragmaもExpiresもこれで代用できる
      -  使い分け
         -  キャッシュさせたくない：Pragmaと`Cache-Control:no-cache`を両方指定する
         -  有効期限が明確に決まっている（絶対的な期限）：Expiresを指定する
         -  有効期限を相対的に指定したい：Cache-Controlのmax-ageを指定する
      -  条件付きGET
         -  If-Modidied-Since: リソースの更新日時を条件にする
            -  設定された日時以降変更がなければ、サーバは304レスポンスを返す
         -  If-None-Match
            -  リソースのETagを条件にする
               -  指定した値にマッチしなければ、という条件。時計の条件ではない
-  持続的接続
   -  クラサバ間でリクエストをまとめて接続し続ける手法
   -  HTTP１.0では`Keep-Alive`ヘッダで実現するが、1.1ではデフォルトの動作になっている
   -  クライアントはレスポンスを待たずに同じサーバにリクエストを送信できる：**パイプライン化**
   -  コネクションを切りたい場合は、リクエスト時にConnectionヘッダに`close`という値を指定する

# 10 HTML
- Hypertext Markup Language
  - マークアップ言語：タグで文書の構造を表現するコンピュータ言語
  - マークアップ構造を持った文書：構造化文書
  - HTML5は仕様策定中の（最新の）HTML
- メディアタイプ
  - `text/html`と`application/xhtml+xml`の2つがある
- 拡張子：`html`
- XMLも知っておく必要がある
  - メタ言語だから
  - 木構造・要素（`<></>`で囲む）
  - XML宣言：XMLのバージョン（1.0 or 1.1で、一般には1.0を使う）や文字エンコーディング方式を指定する
  - 名前空間：複数のXMLフォーマットを組み合わせるときに、名前の衝突を防ぐ目的で使う
  - `xmls:{接頭辞}="名前空間名"`という書き方をする
    - 接頭辞がない時、デフォルトの名前空間であることを意味する
- リンク
  - a, link
- フォーム
  - `<form method={メソッド名} action={URI}/>`でフォーム送信時のリクエストを指定できる

# 11 microformats
- HTMLの中でさらに意味のあるデータを表現するための技術
- セマンティックWeb：Web上の情報に意味を与え、検索エンジンやエージェントなどのプログラムが利用するようになる、と言われてきた
  - 現実的に普及はしていない
- セマンティック
  - 直訳は「意味論」
  - プログラミング言語が持つ意味を確定させるための理論のことを「プログラミング意味論」と呼ぶ
    - コンパイラがプログラムをコンパイルするためには、プログラミング言語の仕様を形式的に記述する必要がある
    - プログラミング言語の世界では、言語の意味論を形式的な数理モデルで表現する
  - Webにおける意味論
    - リソースが持つ意味を確定させるための理論
    - HTMLなどで表現されたテキストがどのような意味を持つかをプログラムでも解釈できるようにする
    - つまり、HTMLやXMLで書かれたリソースの意味をどのようにプログラムから処理するか、に尽きる
- セマンティックWeb：**人間が読んで理解するWebページの意味をプログラムからも処理できるように形式的に意味を記述するための技術**と言える
- RDF：プログラムで処理可能な情報の意味を記述するための仕様
  - リソースの意味を厳密に記述できるが、記述が冗長になる
  - 同じ意味を書く場合でも、主語や述語をどのように選択するか、どのメタデータ表現ボキャブラリを使うかでXML文書の構造が変化するので
  - 統一性を決めるのが難しく、普及せず
- microformats
  - RDFの問題点を解消した技術
    - 書き方 `<a rel="license" href="***"></a>`みたいな感じ
    - rel-licenseというmicroformatsが書かれている（書かれている、であっているのかな）
  - HTMLの`<a>`要素に必要最低限の情報を追加しているだけ
    - 元のHTMLに埋め込むだけなので、記述方法も統一的になる
  - 「より簡単に、もっと気軽にWebページのセマンティクスを記述できるようにしよう」がコンセプトで仕様が決まっている
  - elemental（単純） microformatsとcomputed（複合） microformatsの2つがある
    - elemental
      - リンク関係（aやlinkのrel属性）を使ってメタデータを表現する
      - rel-license
        - ライセンス情報
      - rel-nofollow
        - スパム防止。コメント欄に書かれたURIにはこれをつけるなどしてSEOの悪用を防いだりできる
    - computed
      - class属性を使って階層構造のあるメタデータを表現する
      - h-calender
        - カレンダー情報・イベント情報を記述する
        - h-calenderが定義する階層構造があり、その構造を守りつつclass属性にその構造を入れていく
      - hAtom
        - 更新情報
        - Webページに含まれているエントリの更新日時やパーマリンクなどのメタデータをプログラムから処理可能な形で埋め込む
  - 問題点
    - class属性やrel属性がぶつかると、プログラムの誤判定につながったりする
- RDFa
  - microformatsの名前衝突問題をXMLの名前空間で解決する
  - が、記述が冗長になるという点ではmicroformatsに劣る
  - とりあえずはmicroformatsで大体事足りる
- LDRizeとAutoPagerize
  - microformatsが普及するきっかけになったサービス（なのかはわからないが）
  - microformatsを実装しておくと、実装時点では想定していなかったデータの利用方法が見つかったりする実例になった
  - microformatsによって、WebページをWeb APIとしても使えるようになる
  - 開発コストを下げられる（サービスごとのAPI、とかが不要になる）

# 12 Atom
- Atom Ayndication Format
- XMLフォーマットの1つ
  - ブログの新着情報を伝えるフィードの目的で利用されてきたが、検索エンジンや写真管理などの幅広いWebサービスのWeb APIとして使える

![Atom](./images/image.png)

- エントリ
  - `<entry>`要素をルートにして、子要素がフラットに並ぶ
  - メタデータ（＊の要素は必須）
    - ID（`<id>`）*：エントリを一意に定めるURI形式のID
    - タイトル(`<title>`)*：エントリの題名
    - 著者(`<author>`)*：エントリの著者
    - 更新日時(`<updated>`)*：エントリの更新日時
    - カテゴリ（`<category>`）:そのエントリが属するカテゴリ
      - SNSでいうタグ
      - このカテゴリにおいて`<term>`要素は必須
    - リンク`<link>`
    - たくさんあるので、エントリでどんな要素があるか？を思い出せるかが鍵か？
- フィード：記事一覧・検索一覧的な？
  - エントリの集合
  - エントリと同じメタデータを持てる
  - フィード独自のメタデータ
    - サブタイトル
    - 生成プログラム
    - アイコン：ファビコンのこと
    - ロゴ
- Atomの拡張
  - Atom Thread Extensions: スレッドを表現する
    - 掲示板など、いろんな人が書き込む形式のコンテンツにはAtomの標準では足りない
  - Atom License Extension
    - ライセンス情報を表現する
  - Feed Paging Archiving：フィードを分割する
    - 検索結果が多くなる場合、1つのフィードで表現するのは非現実的。分割したくなる。
    - 1つのコレクションを複数フィードで表現するのがFeed Paging Archiving
    - 完全フィード
    - ページ化フィード
    - アーカイブ済みフィード
  - OpenSearch
    - 検索結果を表現する。検索エンジンのWeb APIのベースとなる仕様になっている
    - リンク関係を使って検索結果をページ化できる
  - 拡張性が高いので、ブログ以外の用途にも用いられている。
  - AtomPubと組み合わせると、HTTP操作もできる

# 13 Atom Publishing Protocol(AtomPub)
- Atomが規定したフィードやエントリで表現するリソースの編集（CRUD操作）を実現するプロトコル
- RESTスタイルに基づいたプロトコル仕様になっている
  - RESTはあくまでアーキテクチャスタイルであって、特定の仕様や実装を指すわけではない
  - アーキテクチャスタイルであるということは、実際の設計は開発者の裁量にあるということであるが、よくわかっていない人にはうまく設計できない、ということでもある
- AtomPubはRESTのこのデメリットを解決してくれる
  - 基本的なリソースモデルとリンク機構を仕様として提供してくれているので、開発者の独自な設計部分が大幅に減る
- 正直なところあまりピンときていないので、また戻ってくる

![alt text](./images/atompub.png)

# 14 JSON(JavaScript Object Notation)
- 軽量なデータ表現形式
  - ハッシュ、配列などプログラミング言語から扱いやすいデータ構造を記述できる
  - JavaScriptの記法でデータを記述できる
  - 多くの言語でライブラリが用意されているので、プログラミング言語が違ってもデータの受け渡しができる
- 組み込みで用意されているデータ型
  - オブジェクト(`{}`で囲まれている)
  - 配列
  - 文字列
    - `""`で囲む
    - `\uXXXX`という形式でエスケープできる
    - `\n`は「改行」になる
  - 数値
  - boolean
  - null
- それ以外のデータ型
  - 日時
    - 組み込みで用意がない。UNIX時間を数値で表現するのが一番単純
    - タイムゾーンを使いたい場合は`toString()`の処理が必要だが、ブラウザによって表記揺れがある
    - より標準的なのはISOフォーマット
  - リンク
    - URI（絶対URIがいい）を文字列として持つのが最も簡単
- JSONP(JSON with Padding)
  - クロスドメイン通信通信を実現する方法
  - クロスドメイン通信の制限
    - XMLHttpRequest（Ajaxで使うJavaScriptモジュール）は、JavaScriptファイルを取得したサーバのみとしか通信できない
      - 違うのと通信できると、ブラウザに入力された情報が不正なサーバに送信できてしまうため
    - ただ、これはサービスを作るという点では（いろんなサーバからデータを取得したいので）不便
  - 解決方法
    - `<script>`タグで複数のサイトからJavaScriptファイルを読み込む（scriptは歴史的経緯でセキュリティ制限を受けない）
    - この性質を利用してクロスドメイン通信を実現するのがJSONP
    - オリジナルのJSONをクライアントが指定したコールバック関数名でラップして、ドメインの異なるサーバからデータを取得する

![alt text](./images/JSONP.jpg)

# 15~17
実践系なのでザッピングした